<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sociology Simulation Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: bold;
            color: #555;
        }
        
        input, select, button {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            height: 800px;
        }
        
        .visualization-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .map-container {
            flex: 1;
            position: relative;
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
            background-color: #87CEEB;
        }
        
        #worldCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #333;
        }
        
        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .info-section {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .info-section h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }
        
        .agent-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .agent-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin-bottom: 5px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .agent-item:hover {
            background-color: #e8f5e8;
        }
        
        .agent-item.selected {
            background-color: #d4edda;
            border-color: #28a745;
        }
        
        .agent-name {
            font-weight: bold;
            color: #333;
        }
        
        .agent-stats {
            font-size: 11px;
            color: #666;
        }
        
        .chat-messages {
            max-height: 150px;
            overflow-y: auto;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 10px;
        }
        
        .chat-message {
            margin-bottom: 8px;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .resource-list {
            max-height: 120px;
            overflow-y: auto;
        }
        
        .resource-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 12px;
        }
        
        .status-bar {
            display: flex;
            gap: 20px;
            padding: 10px;
            background-color: #333;
            color: white;
            border-radius: 5px;
        }
        
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .status-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .status-label {
            font-size: 12px;
            color: #ccc;
        }
        
        .chat-bubble {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 5px 8px;
            font-size: 11px;
            max-width: 150px;
            word-wrap: break-word;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .chat-bubble::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 5px solid #333;
        }
        
        .agent-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1001;
            pointer-events: none;
            max-width: 200px;
        }
        
        .file-input-container {
            position: relative;
            display: inline-block;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 8px 16px;
            background-color: #2196F3;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .file-input-label:hover {
            background-color: #1976D2;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .error-message {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .success-message {
            color: #388e3c;
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sociology Simulation Visualization</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="logFile">Load Simulation Log:</label>
                <div class="file-input-container">
                    <input type="file" id="logFile" accept=".log,.txt">
                    <label for="logFile" class="file-input-label">Choose Log File</label>
                </div>
            </div>
            
            <div class="control-group">
                <label for="turnSelect">Turn:</label>
                <select id="turnSelect">
                    <option value="0">Turn 0</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="showResources">Show Resources:</label>
                <input type="checkbox" id="showResources" checked>
            </div>
            
            <div class="control-group">
                <label for="showAgentNames">Show Agent Names:</label>
                <input type="checkbox" id="showAgentNames" checked>
            </div>
            
            <div class="control-group">
                <label for="showChatBubbles">Show Chat Bubbles:</label>
                <input type="checkbox" id="showChatBubbles" checked>
            </div>
            
            <button onclick="generateSampleData()">Generate Sample Data</button>
            <button onclick="loadRealSimulationData()">Load Real Simulation Data</button>
        </div>
        
        <div class="status-bar">
            <div class="status-item">
                <div class="status-value" id="agentCount">0</div>
                <div class="status-label">Agents</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="currentTurn">0</div>
                <div class="status-label">Turn</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="totalResources">0</div>
                <div class="status-label">Resources</div>
            </div>
            <div class="status-item">
                <div class="status-value" id="activeChats">0</div>
                <div class="status-label">Active Chats</div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="visualization-panel">
                <div class="map-container">
                    <canvas id="worldCanvas"></canvas>
                    <div id="agentTooltip" class="agent-tooltip" style="display: none;"></div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(33, 150, 243);"></div>
                        <span>Ocean</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(76, 175, 80);"></div>
                        <span>Forest</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(170, 221, 119);"></div>
                        <span>Grassland</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(128, 128, 128);"></div>
                        <span>Mountain</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(255, 193, 7);"></div>
                        <span>Desert</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(255, 0, 0);"></div>
                        <span>Agent</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgb(139, 69, 19);"></div>
                        <span>Resources</span>
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <div class="info-section">
                    <h3>Agents</h3>
                    <div class="agent-list" id="agentList"></div>
                </div>
                
                <div class="info-section">
                    <h3>Selected Agent</h3>
                    <div id="selectedAgentInfo">Click on an agent to see details</div>
                </div>
                
                <div class="info-section">
                    <h3>Resources</h3>
                    <div class="resource-list" id="resourceList"></div>
                </div>
                
                <div class="info-section">
                    <h3>Recent Messages</h3>
                    <div class="chat-messages" id="chatMessages"></div>
                </div>
            </div>
        </div>
        
        <div id="messageContainer"></div>
    </div>

    <script>
        // Global variables
        let worldData = null;
        let currentTurn = 0;
        let selectedAgent = null;
        let canvas = null;
        let ctx = null;
        let worldSize = 64;
        let cellSize = 8;
        let chatBubbles = [];
        
        // Terrain colors mapping
        const terrainColors = {
            'OCEAN': [33, 150, 243],
            'FOREST': [76, 175, 80],
            'GRASSLAND': [170, 221, 119],
            'MOUNTAIN': [128, 128, 128],
            'DESERT': [255, 193, 7],
            'RIVER': [45, 178, 230],
            'CAVE': [76, 76, 76],
            'SWAMP': [102, 153, 102],
            'TUNDRA': [204, 229, 229],
            'JUNGLE': [51, 128, 51],
            'PLATEAU': [178, 153, 128],
            'VALLEY': [153, 204, 76],
            'VOLCANIC': [153, 51, 51],
            'OASIS': [76, 204, 153],
            'RUINS': [153, 153, 128],
            'CRYSTAL_CAVE': [204, 102, 229],
            'LAVA_FIELD': [204, 76, 25]
        };
        
        // Initialize the visualization
        function init() {
            canvas = document.getElementById('worldCanvas');
            ctx = canvas.getContext('2d');
            
            // Set up event listeners
            document.getElementById('logFile').addEventListener('change', handleFileLoad);
            document.getElementById('turnSelect').addEventListener('change', handleTurnChange);
            document.getElementById('showResources').addEventListener('change', renderWorld);
            document.getElementById('showAgentNames').addEventListener('change', renderWorld);
            document.getElementById('showChatBubbles').addEventListener('change', renderWorld);
            
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasHover);
            
            // Initial render
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Generate sample data by default
            generateSampleData();
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width - 4; // Account for border
            canvas.height = rect.height - 4;
            
            if (worldData) {
                cellSize = Math.min(canvas.width / worldSize, canvas.height / worldSize);
                renderWorld();
            }
        }
        
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    if (file.name.endsWith('.json')) {
                        loadJsonData(e.target.result);
                        showMessage('JSON data loaded successfully!', 'success');
                    } else {
                        parseLogFile(e.target.result);
                        showMessage('Log file loaded successfully!', 'success');
                    }
                } catch (error) {
                    showMessage('Error parsing file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        function loadJsonData(jsonContent) {
            // Load simulation data from JSON export
            const data = JSON.parse(jsonContent);
            
            worldData = {
                size: data.metadata.world_size,
                turns: data.turns,
                terrain: data.world.terrain,
                resources: data.world.resources,
                metadata: data.metadata
            };
            
            // Update world size
            worldSize = data.metadata.world_size;
            
            updateTurnSelector();
            setTurn(0);
        }
        
        function parseLogFile(logContent) {
            // Parse the log file to extract simulation data
            const lines = logContent.split('\n');
            const turns = [];
            let currentTurnData = null;
            
            for (let line of lines) {
                // Extract turn information
                if (line.includes('===== TURN')) {
                    const turnMatch = line.match(/TURN (\d+)/);
                    if (turnMatch) {
                        if (currentTurnData) {
                            turns.push(currentTurnData);
                        }
                        currentTurnData = {
                            turn: parseInt(turnMatch[1]),
                            agents: [],
                            conversations: [],
                            events: []
                        };
                    }
                }
                
                // Extract agent information
                if (line.includes('行动 →') || line.includes('personal goal')) {
                    const agentMatch = line.match(/(\w+)\((\d+)\)/);
                    if (agentMatch && currentTurnData) {
                        currentTurnData.events.push({
                            type: 'action',
                            agent: agentMatch[1],
                            agentId: parseInt(agentMatch[2]),
                            content: line
                        });
                    }
                }
                
                // Extract conversations
                if (line.includes('↔')) {
                    if (currentTurnData) {
                        currentTurnData.conversations.push(line);
                    }
                }
            }
            
            if (currentTurnData) {
                turns.push(currentTurnData);
            }
            
            // Create world data structure
            worldData = {
                size: worldSize,
                turns: turns,
                terrain: generateSampleTerrain(),
                resources: generateSampleResources()
            };
            
            updateTurnSelector();
            setTurn(0);
        }
        
        function loadRealSimulationData() {
            // Try to load real simulation data from the exported JSON file
            fetch('real_simulation_data.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    loadJsonData(JSON.stringify(data));
                    showMessage('Real simulation data loaded successfully!', 'success');
                })
                .catch(error => {
                    console.error('Error loading real simulation data:', error);
                    showMessage('Could not load real simulation data. Using sample data instead.', 'error');
                    generateSampleData();
                });
        }
        
        function generateSampleData() {
            // Generate sample simulation data for demonstration
            worldData = {
                size: worldSize,
                turns: [],
                terrain: generateSampleTerrain(),
                resources: generateSampleResources()
            };
            
            // Generate sample turns
            for (let t = 0; t < 10; t++) {
                const agents = generateSampleAgents(t);
                const conversations = generateSampleConversations(agents);
                
                worldData.turns.push({
                    turn: t,
                    agents: agents,
                    conversations: conversations,
                    events: []
                });
            }
            
            updateTurnSelector();
            setTurn(0);
            showMessage('Sample data generated successfully!', 'success');
        }
        
        function generateSampleTerrain() {
            const terrain = [];
            for (let y = 0; y < worldSize; y++) {
                const row = [];
                for (let x = 0; x < worldSize; x++) {
                    // Generate varied terrain
                    const distance = Math.sqrt((x - worldSize/2)**2 + (y - worldSize/2)**2);
                    const noise = Math.random() * 0.5;
                    
                    if (distance < 10 + noise * 5) {
                        row.push('GRASSLAND');
                    } else if (distance < 20 + noise * 8) {
                        row.push(Math.random() > 0.5 ? 'FOREST' : 'GRASSLAND');
                    } else if (distance < 28 + noise * 5) {
                        row.push(Math.random() > 0.3 ? 'MOUNTAIN' : 'FOREST');
                    } else {
                        row.push('OCEAN');
                    }
                }
                terrain.push(row);
            }
            return terrain;
        }
        
        function generateSampleResources() {
            const resources = {};
            
            // Generate resources based on terrain
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    const terrain = worldData?.terrain?.[y]?.[x];
                    if (!terrain) continue;
                    
                    const pos = `${x},${y}`;
                    resources[pos] = {};
                    
                    // Add resources based on terrain type
                    switch (terrain) {
                        case 'FOREST':
                            if (Math.random() > 0.5) resources[pos].wood = Math.floor(Math.random() * 3) + 1;
                            if (Math.random() > 0.7) resources[pos].apple = Math.floor(Math.random() * 2) + 1;
                            break;
                        case 'OCEAN':
                            if (Math.random() > 0.6) resources[pos].fish = Math.floor(Math.random() * 2) + 1;
                            break;
                        case 'MOUNTAIN':
                            if (Math.random() > 0.4) resources[pos].stone = Math.floor(Math.random() * 3) + 1;
                            if (Math.random() > 0.9) resources[pos].magical_crystal = 1;
                            break;
                        case 'GRASSLAND':
                            if (Math.random() > 0.8) resources[pos].apple = Math.floor(Math.random() * 2) + 1;
                            break;
                    }
                }
            }
            
            return resources;
        }
        
        function generateSampleAgents(turn) {
            const agents = [];
            const names = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Henry', 'Ivy', 'Jack'];
            
            for (let i = 0; i < 20; i++) {
                const baseX = Math.floor(Math.random() * worldSize);
                const baseY = Math.floor(Math.random() * worldSize);
                
                // Add some movement over time
                const x = Math.max(0, Math.min(worldSize - 1, baseX + Math.floor((Math.random() - 0.5) * turn)));
                const y = Math.max(0, Math.min(worldSize - 1, baseY + Math.floor((Math.random() - 0.5) * turn)));
                
                agents.push({
                    id: i,
                    name: names[i % names.length] + (i >= names.length ? Math.floor(i / names.length) : ''),
                    pos: [x, y],
                    age: 25 + Math.floor(Math.random() * 30),
                    health: 80 + Math.floor(Math.random() * 20),
                    hunger: Math.floor(Math.random() * 50),
                    attributes: {
                        strength: Math.floor(Math.random() * 10) + 1,
                        curiosity: Math.floor(Math.random() * 10) + 1,
                        charm: Math.floor(Math.random() * 10) + 1
                    },
                    inventory: {
                        wood: Math.floor(Math.random() * 5),
                        stone: Math.floor(Math.random() * 3),
                        apple: Math.floor(Math.random() * 2)
                    },
                    goal: 'Explore the world and gather resources',
                    recentMessages: turn > 0 ? [
                        `Turn ${turn}: Looking for resources`,
                        `Turn ${turn}: Exploring nearby areas`
                    ] : []
                });
            }
            
            return agents;
        }
        
        function generateSampleConversations(agents) {
            const conversations = [];
            const topics = ['weather', 'resources', 'exploration', 'tools', 'cooperation'];
            
            for (let i = 0; i < 5; i++) {
                const agent1 = agents[Math.floor(Math.random() * agents.length)];
                const agent2 = agents[Math.floor(Math.random() * agents.length)];
                
                if (agent1.id !== agent2.id) {
                    const topic = topics[Math.floor(Math.random() * topics.length)];
                    conversations.push(`${agent1.name}(${agent1.id}) ↔ ${agent2.name}(${agent2.id}): Discussing ${topic}`);
                }
            }
            
            return conversations;
        }
        
        function updateTurnSelector() {
            const select = document.getElementById('turnSelect');
            select.innerHTML = '';
            
            if (worldData && worldData.turns) {
                worldData.turns.forEach((turn, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Turn ${turn.turn}`;
                    select.appendChild(option);
                });
            }
        }
        
        function handleTurnChange() {
            const select = document.getElementById('turnSelect');
            setTurn(parseInt(select.value));
        }
        
        function setTurn(turn) {
            currentTurn = turn;
            document.getElementById('turnSelect').value = turn;
            updateUI();
            renderWorld();
        }
        
        function updateUI() {
            if (!worldData || !worldData.turns[currentTurn]) return;
            
            const turnData = worldData.turns[currentTurn];
            
            // Update status bar
            document.getElementById('agentCount').textContent = turnData.agents.length;
            document.getElementById('currentTurn').textContent = turnData.turn;
            document.getElementById('activeChats').textContent = turnData.conversations.length;
            
            // Count total resources
            let totalResources = 0;
            for (const pos in worldData.resources) {
                for (const resource in worldData.resources[pos]) {
                    totalResources += worldData.resources[pos][resource];
                }
            }
            document.getElementById('totalResources').textContent = totalResources;
            
            // Update agent list
            updateAgentList();
            
            // Update resource list
            updateResourceList();
            
            // Update chat messages
            updateChatMessages();
        }
        
        function updateAgentList() {
            const agentList = document.getElementById('agentList');
            agentList.innerHTML = '';
            
            if (!worldData || !worldData.turns[currentTurn]) return;
            
            worldData.turns[currentTurn].agents.forEach(agent => {
                const agentDiv = document.createElement('div');
                agentDiv.className = 'agent-item';
                agentDiv.onclick = () => selectAgent(agent);
                
                agentDiv.innerHTML = `
                    <div>
                        <div class="agent-name">${agent.name}</div>
                        <div class="agent-stats">Age: ${agent.age} | Health: ${agent.health}%</div>
                    </div>
                    <div class="agent-stats">
                        (${agent.pos[0]}, ${agent.pos[1]})
                    </div>
                `;
                
                agentList.appendChild(agentDiv);
            });
        }
        
        function selectAgent(agent) {
            selectedAgent = agent;
            
            // Update selection visual
            document.querySelectorAll('.agent-item').forEach(item => {
                item.classList.remove('selected');
            });
            event.target.closest('.agent-item').classList.add('selected');
            
            // Update selected agent info
            updateSelectedAgentInfo();
            renderWorld();
        }
        
        function updateSelectedAgentInfo() {
            const infoDiv = document.getElementById('selectedAgentInfo');
            
            if (!selectedAgent) {
                infoDiv.innerHTML = 'Click on an agent to see details';
                return;
            }
            
            const inventoryItems = Object.entries(selectedAgent.inventory)
                .map(([item, count]) => `${item}: ${count}`)
                .join(', ');
            
            const attributeItems = Object.entries(selectedAgent.attributes)
                .map(([attr, value]) => `${attr}: ${value}`)
                .join(', ');
            
            infoDiv.innerHTML = `
                <strong>${selectedAgent.name} (ID: ${selectedAgent.id})</strong><br>
                <strong>Position:</strong> (${selectedAgent.pos[0]}, ${selectedAgent.pos[1]})<br>
                <strong>Age:</strong> ${selectedAgent.age}<br>
                <strong>Health:</strong> ${selectedAgent.health}%<br>
                <strong>Hunger:</strong> ${selectedAgent.hunger}%<br>
                <strong>Attributes:</strong> ${attributeItems}<br>
                <strong>Inventory:</strong> ${inventoryItems}<br>
                <strong>Goal:</strong> ${selectedAgent.goal}
            `;
        }
        
        function updateResourceList() {
            const resourceList = document.getElementById('resourceList');
            resourceList.innerHTML = '';
            
            if (!worldData || !worldData.resources) return;
            
            const resourceTotals = {};
            
            // Calculate resource totals
            for (const pos in worldData.resources) {
                for (const resource in worldData.resources[pos]) {
                    resourceTotals[resource] = (resourceTotals[resource] || 0) + worldData.resources[pos][resource];
                }
            }
            
            // Display resource totals
            Object.entries(resourceTotals).forEach(([resource, total]) => {
                const resourceDiv = document.createElement('div');
                resourceDiv.className = 'resource-item';
                resourceDiv.innerHTML = `
                    <span>${resource}</span>
                    <span>${total}</span>
                `;
                resourceList.appendChild(resourceDiv);
            });
        }
        
        function updateChatMessages() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            
            if (!worldData || !worldData.turns[currentTurn]) return;
            
            worldData.turns[currentTurn].conversations.forEach(conv => {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message';
                messageDiv.textContent = conv;
                chatMessages.appendChild(messageDiv);
            });
        }
        
        function renderWorld() {
            if (!worldData || !ctx) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate cell size
            cellSize = Math.min(canvas.width / worldSize, canvas.height / worldSize);
            
            // Draw terrain
            drawTerrain();
            
            // Draw resources
            if (document.getElementById('showResources').checked) {
                drawResources();
            }
            
            // Draw agents
            drawAgents();
            
            // Draw chat bubbles
            if (document.getElementById('showChatBubbles').checked) {
                drawChatBubbles();
            }
        }
        
        function drawTerrain() {
            if (!worldData || !worldData.terrain) return;
            
            for (let y = 0; y < worldSize; y++) {
                for (let x = 0; x < worldSize; x++) {
                    if (worldData.terrain[y] && worldData.terrain[y][x]) {
                        const terrain = worldData.terrain[y][x];
                        const color = terrainColors[terrain] || [128, 128, 128];
                        
                        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }
        
        function drawResources() {
            for (const pos in worldData.resources) {
                const [x, y] = pos.split(',').map(Number);
                const resources = worldData.resources[pos];
                
                if (Object.keys(resources).length > 0) {
                    ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
                    ctx.fillRect(x * cellSize + 2, y * cellSize + 2, cellSize - 4, cellSize - 4);
                    
                    // Draw resource count
                    const total = Object.values(resources).reduce((sum, count) => sum + count, 0);
                    if (total > 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = `${Math.max(8, cellSize / 3)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(total.toString(), x * cellSize + cellSize / 2, y * cellSize + cellSize / 2 + 2);
                    }
                }
            }
        }
        
        function drawAgents() {
            if (!worldData.turns[currentTurn]) return;
            
            worldData.turns[currentTurn].agents.forEach(agent => {
                const [x, y] = agent.pos;
                
                // Draw agent circle
                ctx.fillStyle = selectedAgent && selectedAgent.id === agent.id ? 'red' : 'darkred';
                ctx.beginPath();
                ctx.arc(x * cellSize + cellSize / 2, y * cellSize + cellSize / 2, cellSize / 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw agent name
                if (document.getElementById('showAgentNames').checked) {
                    ctx.fillStyle = 'white';
                    ctx.font = `${Math.max(8, cellSize / 4)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(agent.name, x * cellSize + cellSize / 2, y * cellSize - 2);
                }
                
                // Draw health bar
                const healthBarWidth = cellSize * 0.8;
                const healthBarHeight = 3;
                const healthRatio = agent.health / 100;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(x * cellSize + (cellSize - healthBarWidth) / 2, y * cellSize + cellSize - 8, healthBarWidth, healthBarHeight);
                
                ctx.fillStyle = healthRatio > 0.5 ? 'green' : healthRatio > 0.2 ? 'yellow' : 'red';
                ctx.fillRect(x * cellSize + (cellSize - healthBarWidth) / 2, y * cellSize + cellSize - 8, healthBarWidth * healthRatio, healthBarHeight);
            });
        }
        
        function drawChatBubbles() {
            // Clear existing chat bubbles
            document.querySelectorAll('.chat-bubble').forEach(bubble => bubble.remove());
            
            if (!worldData.turns[currentTurn]) return;
            
            // Show recent conversations as chat bubbles
            worldData.turns[currentTurn].conversations.forEach((conv, index) => {
                const agentMatch = conv.match(/(\w+)\((\d+)\)/);
                if (agentMatch) {
                    const agentName = agentMatch[1];
                    const agentId = parseInt(agentMatch[2]);
                    const agent = worldData.turns[currentTurn].agents.find(a => a.id === agentId);
                    
                    if (agent) {
                        const bubble = document.createElement('div');
                        bubble.className = 'chat-bubble';
                        bubble.textContent = conv.split('↔')[1] || conv.split(':')[1] || 'Chat';
                        bubble.style.left = `${agent.pos[0] * cellSize + cellSize / 2}px`;
                        bubble.style.top = `${agent.pos[1] * cellSize - 30}px`;
                        bubble.style.transform = 'translateX(-50%)';
                        
                        canvas.parentElement.appendChild(bubble);
                        
                        // Auto-hide after 5 seconds
                        setTimeout(() => {
                            if (bubble.parentElement) {
                                bubble.parentElement.removeChild(bubble);
                            }
                        }, 5000);
                    }
                }
            });
        }
        
        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / cellSize);
            const y = Math.floor((event.clientY - rect.top) / cellSize);
            
            if (!worldData.turns[currentTurn]) return;
            
            // Check if clicked on an agent
            const clickedAgent = worldData.turns[currentTurn].agents.find(agent => 
                agent.pos[0] === x && agent.pos[1] === y
            );
            
            if (clickedAgent) {
                selectAgent(clickedAgent);
            }
        }
        
        function handleCanvasHover(event) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / cellSize);
            const y = Math.floor((event.clientY - rect.top) / cellSize);
            const tooltip = document.getElementById('agentTooltip');
            
            if (!worldData.turns[currentTurn]) return;
            
            // Check if hovering over an agent
            const hoveredAgent = worldData.turns[currentTurn].agents.find(agent => 
                agent.pos[0] === x && agent.pos[1] === y
            );
            
            if (hoveredAgent) {
                tooltip.innerHTML = `
                    <strong>${hoveredAgent.name}</strong><br>
                    Age: ${hoveredAgent.age}<br>
                    Health: ${hoveredAgent.health}%<br>
                    Hunger: ${hoveredAgent.hunger}%
                `;
                tooltip.style.left = `${event.clientX - rect.left + 10}px`;
                tooltip.style.top = `${event.clientY - rect.top - 10}px`;
                tooltip.style.display = 'block';
            } else {
                tooltip.style.display = 'none';
            }
        }
        
        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = message;
            
            container.appendChild(messageDiv);
            
            // Remove message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentElement) {
                    messageDiv.parentElement.removeChild(messageDiv);
                }
            }, 5000);
        }
        
        // Initialize on page load
        window.addEventListener('load', init);
    </script>
</body>
</html>