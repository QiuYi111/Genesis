"""Enhanced Bible class for managing dynamic simulation rules"""
import json
import time
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Set
from enum import Enum
from loguru import logger


class RuleCategory(Enum):
    """Categories of rules for organization"""
    PHYSICS = "physics"          # 物理规律
    RESOURCES = "resources"      # 资源规则
    SKILLS = "skills"           # 技能系统
    ACTIONS = "actions"         # 行为规则
    ITEMS = "items"             # 物品系统
    ATTRIBUTES = "attributes"   # 属性系统
    SOCIAL = "social"           # 社会规则
    INTERACTIONS = "interactions" # 交互规则
    ECONOMICS = "economics"     # 经济规则
    CULTURE = "culture"         # 文化规范
    MAGIC = "magic"             # 超自然规则
    TECHNOLOGY = "technology"   # 科技规则


@dataclass
class Rule:
    """Individual rule definition"""
    id: str
    name: str
    category: RuleCategory
    description: str
    parameters: Dict[str, Any] = field(default_factory=dict)
    conditions: List[str] = field(default_factory=list)  # 启用条件
    effects: List[str] = field(default_factory=list)     # 效果描述
    priority: int = 1  # 1-10, 10最高优先级
    version: int = 1
    created_time: float = field(default_factory=time.time)
    active: bool = True
    conflicts_with: Set[str] = field(default_factory=set)  # 冲突规则ID
    dependencies: Set[str] = field(default_factory=set)    # 依赖规则ID
    usage_count: int = 0
    success_rate: float = 1.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert rule to dictionary for LLM consumption"""
        return {
            "id": self.id,
            "name": self.name,
            "category": self.category.value,
            "description": self.description,
            "parameters": self.parameters,
            "conditions": self.conditions,
            "effects": self.effects,
            "priority": self.priority,
            "active": self.active
        }


@dataclass
class RuleSet:
    """Collection of rules with metadata"""
    name: str
    description: str
    rules: Dict[str, Rule] = field(default_factory=dict)
    era_context: str = ""
    version: int = 1
    created_time: float = field(default_factory=time.time)
    
    def get_active_rules(self, category: Optional[RuleCategory] = None) -> Dict[str, Rule]:
        """Get all active rules, optionally filtered by category"""
        filtered = {}
        for rule_id, rule in self.rules.items():
            if rule.active and (category is None or rule.category == category):
                filtered[rule_id] = rule
        return filtered


class Bible:
    """Enhanced dynamic rule management system
    
    The Bible serves as the comprehensive rule repository that ActionHandler
    consults for all decisions. Rules are dynamically generated by Trinity
    and can evolve during simulation.
    """
    
    def __init__(self):
        # Core rule storage
        self.rule_sets: Dict[str, RuleSet] = {}
        self.active_rule_set: str = "default"
        self.rule_history: List[Dict[str, Any]] = []
        
        # Rule management
        self.rule_conflicts: Dict[str, Set[str]] = {}
        self.rule_usage_stats: Dict[str, Dict[str, Any]] = {}
        
        # Dynamic generation tracking
        self.generation_context: Dict[str, Any] = {}
        self.pending_rules: List[Dict[str, Any]] = []
        
        # Create default rule set
        self._initialize_default_rules()
    
    def _initialize_default_rules(self):
        """Initialize with minimal default rules"""
        default_set = RuleSet(
            name="default",
            description="Basic simulation rules",
            era_context="generic"
        )
        
        # Add basic physics rule
        basic_physics = Rule(
            id="basic_physics",
            name="基础物理定律",
            category=RuleCategory.PHYSICS,
            description="物体不能同时占据同一位置，移动需要时间",
            parameters={"movement_cost": 1, "collision_detection": True},
            priority=10
        )
        default_set.rules["basic_physics"] = basic_physics
        
        self.rule_sets["default"] = default_set
    
    def apply_to_perception(self, perception: Dict[str, Any]) -> Dict[str, Any]:
        """Apply relevant rules to agent perception"""
        active_rules = self.get_active_rules()
        
        # Convert rules to LLM-friendly format
        rules_for_llm = {
            "physics_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.PHYSICS],
            "resource_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.RESOURCES],
            "skill_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.SKILLS],
            "action_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.ACTIONS],
            "item_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.ITEMS],
            "social_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.SOCIAL],
            "interaction_rules": [r.to_dict() for r in active_rules if r.category == RuleCategory.INTERACTIONS],
        }
        
        perception["rules"] = rules_for_llm
        perception["rule_context"] = {
            "total_rules": len(active_rules),
            "rule_set": self.active_rule_set,
            "era_context": self.rule_sets[self.active_rule_set].era_context
        }
        
        return perception
    
    def get_rules_for_action_handler(self, action_type: str = None) -> Dict[str, Any]:
        """Get comprehensive rules for ActionHandler to consult"""
        active_rules = self.get_active_rules()
        
        # Organize rules by relevance to action type
        relevant_rules = {
            "all_rules": [r.to_dict() for r in active_rules],
            "by_category": {},
            "high_priority": [r.to_dict() for r in active_rules if r.priority >= 8],
            "conflict_resolution": self._get_conflict_resolution_rules(),
            "rule_dependencies": self._get_rule_dependencies()
        }
        
        # Group by category
        for category in RuleCategory:
            category_rules = [r.to_dict() for r in active_rules if r.category == category]
            if category_rules:
                relevant_rules["by_category"][category.value] = category_rules
        
        # Add contextual information
        relevant_rules["meta"] = {
            "rule_set_name": self.active_rule_set,
            "era_context": self.rule_sets[self.active_rule_set].era_context,
            "total_active_rules": len(active_rules),
            "last_update": time.time()
        }
        
        return relevant_rules
    
    def add_rule(self, rule: Rule, rule_set_name: str = None) -> bool:
        """Add a new rule to the specified rule set"""
        if rule_set_name is None:
            rule_set_name = self.active_rule_set
        
        if rule_set_name not in self.rule_sets:
            logger.warning(f"Rule set {rule_set_name} does not exist")
            return False
        
        # Check for conflicts
        if self._has_conflicts(rule, rule_set_name):
            logger.warning(f"Rule {rule.id} conflicts with existing rules")
            return False
        
        # Add rule
        self.rule_sets[rule_set_name].rules[rule.id] = rule
        
        # Log the addition
        self.rule_history.append({
            "action": "add",
            "rule_id": rule.id,
            "rule_set": rule_set_name,
            "timestamp": time.time(),
            "rule_data": rule.to_dict()
        })
        
        logger.success(f"[Bible] Added rule: {rule.name} ({rule.id}) to {rule_set_name}")
        return True
    
    def update_rule(self, rule_id: str, updates: Dict[str, Any], rule_set_name: str = None) -> bool:
        """Update an existing rule"""
        if rule_set_name is None:
            rule_set_name = self.active_rule_set
        
        if rule_set_name not in self.rule_sets or rule_id not in self.rule_sets[rule_set_name].rules:
            logger.warning(f"Rule {rule_id} not found in {rule_set_name}")
            return False
        
        rule = self.rule_sets[rule_set_name].rules[rule_id]
        old_data = rule.to_dict()
        
        # Apply updates
        for key, value in updates.items():
            if hasattr(rule, key):
                setattr(rule, key, value)
        
        rule.version += 1
        
        # Log the update
        self.rule_history.append({
            "action": "update",
            "rule_id": rule_id,
            "rule_set": rule_set_name,
            "timestamp": time.time(),
            "old_data": old_data,
            "new_data": rule.to_dict(),
            "updates": updates
        })
        
        logger.success(f"[Bible] Updated rule: {rule.name} ({rule_id})")
        return True
    
    def deactivate_rule(self, rule_id: str, reason: str = "", rule_set_name: str = None) -> bool:
        """Deactivate a rule without removing it"""
        if rule_set_name is None:
            rule_set_name = self.active_rule_set
        
        if rule_set_name not in self.rule_sets or rule_id not in self.rule_sets[rule_set_name].rules:
            logger.warning(f"Rule {rule_id} not found in {rule_set_name}")
            return False
        
        self.rule_sets[rule_set_name].rules[rule_id].active = False
        
        # Log the deactivation
        self.rule_history.append({
            "action": "deactivate",
            "rule_id": rule_id,
            "rule_set": rule_set_name,
            "timestamp": time.time(),
            "reason": reason
        })
        
        logger.info(f"[Bible] Deactivated rule: {rule_id} - {reason}")
        return True
    
    def get_active_rules(self, category: Optional[RuleCategory] = None, rule_set_name: str = None) -> List[Rule]:
        """Get all active rules, optionally filtered by category"""
        if rule_set_name is None:
            rule_set_name = self.active_rule_set
        
        if rule_set_name not in self.rule_sets:
            return []
        
        active_rules = self.rule_sets[rule_set_name].get_active_rules(category)
        return list(active_rules.values())
    
    def create_rule_set(self, name: str, description: str, era_context: str = "") -> bool:
        """Create a new rule set"""
        if name in self.rule_sets:
            logger.warning(f"Rule set {name} already exists")
            return False
        
        self.rule_sets[name] = RuleSet(
            name=name,
            description=description,
            era_context=era_context
        )
        
        logger.success(f"[Bible] Created rule set: {name}")
        return True
    
    def switch_rule_set(self, name: str) -> bool:
        """Switch to a different rule set"""
        if name not in self.rule_sets:
            logger.warning(f"Rule set {name} does not exist")
            return False
        
        old_set = self.active_rule_set
        self.active_rule_set = name
        
        logger.info(f"[Bible] Switched from rule set '{old_set}' to '{name}'")
        return True
    
    def record_rule_usage(self, rule_id: str, success: bool, context: Dict[str, Any] = None):
        """Record usage statistics for a rule"""
        if rule_id not in self.rule_usage_stats:
            self.rule_usage_stats[rule_id] = {
                "usage_count": 0,
                "success_count": 0,
                "failure_count": 0,
                "success_rate": 0.0,
                "contexts": []
            }
        
        stats = self.rule_usage_stats[rule_id]
        stats["usage_count"] += 1
        
        if success:
            stats["success_count"] += 1
        else:
            stats["failure_count"] += 1
        
        stats["success_rate"] = stats["success_count"] / stats["usage_count"]
        
        if context:
            stats["contexts"].append({
                "timestamp": time.time(),
                "success": success,
                "context": context
            })
            
            # Keep only last 10 contexts
            if len(stats["contexts"]) > 10:
                stats["contexts"] = stats["contexts"][-10:]
        
        # Update rule success rate
        for rule_set in self.rule_sets.values():
            if rule_id in rule_set.rules:
                rule_set.rules[rule_id].usage_count = stats["usage_count"]
                rule_set.rules[rule_id].success_rate = stats["success_rate"]
                break
    
    def get_rule_statistics(self) -> Dict[str, Any]:
        """Get comprehensive rule usage statistics"""
        total_rules = sum(len(rs.rules) for rs in self.rule_sets.values())
        active_rules = len(self.get_active_rules())
        
        category_stats = {}
        for category in RuleCategory:
            category_rules = self.get_active_rules(category)
            category_stats[category.value] = {
                "count": len(category_rules),
                "avg_usage": sum(r.usage_count for r in category_rules) / max(len(category_rules), 1),
                "avg_success_rate": sum(r.success_rate for r in category_rules) / max(len(category_rules), 1)
            }
        
        return {
            "total_rules": total_rules,
            "active_rules": active_rules,
            "rule_sets": len(self.rule_sets),
            "active_rule_set": self.active_rule_set,
            "category_statistics": category_stats,
            "rule_history_size": len(self.rule_history),
            "most_used_rules": self._get_most_used_rules(5),
            "least_successful_rules": self._get_least_successful_rules(5)
        }
    
    def _has_conflicts(self, new_rule: Rule, rule_set_name: str) -> bool:
        """Check if a new rule conflicts with existing rules"""
        existing_rules = self.rule_sets[rule_set_name].rules
        
        for existing_rule in existing_rules.values():
            if new_rule.id in existing_rule.conflicts_with or existing_rule.id in new_rule.conflicts_with:
                return True
        
        return False
    
    def _get_conflict_resolution_rules(self) -> List[Dict[str, Any]]:
        """Get rules for handling conflicts between rules"""
        return [
            {
                "type": "priority_override",
                "description": "Higher priority rules override lower priority ones"
            },
            {
                "type": "context_specific",
                "description": "Rules with more specific conditions take precedence"
            },
            {
                "type": "newer_version",
                "description": "Newer versions of rules override older ones"
            }
        ]
    
    def _get_rule_dependencies(self) -> Dict[str, List[str]]:
        """Get rule dependency mappings"""
        dependencies = {}
        for rule_set in self.rule_sets.values():
            for rule in rule_set.rules.values():
                if rule.dependencies:
                    dependencies[rule.id] = list(rule.dependencies)
        return dependencies
    
    def _get_most_used_rules(self, count: int) -> List[Dict[str, Any]]:
        """Get the most frequently used rules"""
        usage_data = []
        for rule_id, stats in self.rule_usage_stats.items():
            usage_data.append({
                "rule_id": rule_id,
                "usage_count": stats["usage_count"],
                "success_rate": stats["success_rate"]
            })
        
        usage_data.sort(key=lambda x: x["usage_count"], reverse=True)
        return usage_data[:count]
    
    def _get_least_successful_rules(self, count: int) -> List[Dict[str, Any]]:
        """Get the least successful rules"""
        usage_data = []
        for rule_id, stats in self.rule_usage_stats.items():
            if stats["usage_count"] >= 3:  # Only consider rules used at least 3 times
                usage_data.append({
                    "rule_id": rule_id,
                    "usage_count": stats["usage_count"],
                    "success_rate": stats["success_rate"]
                })
        
        usage_data.sort(key=lambda x: x["success_rate"])
        return usage_data[:count]
    
    # Legacy compatibility methods
    def update(self, new_rules: Dict[str, str]):
        """Legacy method for backward compatibility"""
        for rule_name, rule_description in new_rules.items():
            rule = Rule(
                id=f"legacy_{rule_name}",
                name=rule_name,
                category=RuleCategory.SOCIAL,  # Default to social
                description=rule_description
            )
            self.add_rule(rule)
        
        logger.success(f"[Bible] Added {len(new_rules)} legacy rules")
    
    def apply(self, perception: Dict[str, Any]) -> Dict[str, Any]:
        """Legacy method - alias for apply_to_perception"""
        return self.apply_to_perception(perception)
